#!/bin/sh
# jenkins-run.sh - starts or restarts an api with docker
# usually called remotely by jenkins

# usage: start-container.sh API-NAME

set -eu

api=${1:-}
if [ -z "$api" ]; then
    echo 2>&1 "usage: jenkins-run.sh API-NAME"
    exit 1
fi
if [ "$(echo $api | tr -d "A-Za-z0-9-_")" ]; then
    echo 2>&1 "invalid api name: $api"
    exit 1
fi
if [ ! -d /apis/apis/"$api" ]; then
    echo 2>&1 "api does not exist: $api"
    exit 1
fi

api_path=/apis/apis/$api
cd $api_path &&

archive=$(ls "$api"-*-all.jar | sort | tail -1)
config=/apis/config/$api.yaml
env=/apis/env/$api.env
keytool_path=/apis/keytool_files

if [ ! -e "$config" ]; then
    config=/apis/apis/$api/configuration.yaml
fi

uid="$(id -u {{ api_user }})"
gid="$(id -g {{ api_user }})"

# Stop and destroy container if it's already running
if [[ "$(docker ps -aq -f name=$api)" ]]; then
    echo "Stop existing container"
    docker stop "$api"
    docker rm "$api"

    # Sometimes docker will still think a container exists after doing "docker rm"
    # Pause the script for a few seconds before creating the container again
    until [[ ! "$(docker ps -aq -f name=$api)" ]]; do
        sleep 1
    done
fi

echo "Start container"

java_command="java -Xmx100m -jar $archive server $config"

docker run \
    -d \
    --name "$api" \
    --label jar=$archive \
    --restart on-failure:3 \
    --user="$uid:$gid" \
    --workdir="$api_path" \
    --env-file "$env" \
    --network host \
    --health-cmd='curl -k -fsS https://localhost:$ADMIN_PORT/healthcheck' \
    --health-interval=1m \
    --volume $keytool_path/server.keystore:$keytool_path/server.keystore:ro \
    --volume $keytool_path/server.truststore:$keytool_path/server.truststore:ro \
    --volume $api_path:$api_path \
    --volume $config:$config:ro \
    {{ dropwizard_docker_image }} \
    /bin/bash -c "$java_command"

if [[ ! $(docker ps -q -f name=$api) ]]; then
    echo "ERROR: Container not running"
    exit 1
fi
